"""
This security layer inadequately handles A/B storage for files in RepyV2.

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
    """ 

TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"

# Globals
mycontext['debug'] = False

class ABFile:
    def __init__(self, filename, create):
        self.Afn = filename + '.a'
        self.Bfn = filename + '.b'
        self.lock = createlock()  # Give lock to A and to B

        self.lock.acquire(True)
        try:
            if create:
                if self.Afn in listfiles():
                    afile = openfile(self.Afn, False)
                    data = afile.readat(None, 0)
                    afile.close()

                    self.Afile = openfile(self.Afn, True)
                    self.Bfile = openfile(self.Bfn, True)
                    self.Bfile.writeat(data, 0)
                else:
                    self.Afile = openfile(self.Afn, True)
                    self.Bfile = openfile(self.Bfn, True)
                    self.Afile.writeat('SE', 0)
                    self.Bfile.writeat('SE', 0)
            else:
                if self.Afn in listfiles():
                    self.Afile = openfile(self.Afn, False)
                    self.Bfile = openfile(self.Bfn, False)
        finally:
            self.lock.release()

    def writeat(self, data, offset):
        self.lock.acquire(True)
        try:
            current = self.Bfile.readat(None, 0)
            current_length = len(current)

            if (offset == 0 and data.startswith(' ')) or (not current and data.startswith(' ')) or (offset > current_length):
                return

            self.Bfile.writeat(data, offset)
        finally:
            self.lock.release()

    def readat(self, bytes, offset):
        self.lock.acquire(True)
        try:
            return self.Afile.readat(bytes, offset)
        finally:
            self.lock.release()

    def close(self):
        self.lock.acquire(True)
        try:
            data = self.Bfile.readat(None, 0)
            if data and len(data) >= 2 and data[0] == 'S' and data[-1] == 'E':
                self.Afile.close()
                removefile(self.Afn)
                self.Afile = openfile(self.Afn, True)
                self.Afile.writeat(data, 0)

            self.Afile.close()
            self.Bfile.close()
        finally:
            self.lock.release()

def ABopenfile(filename, create):
    return ABFile(filename, create)


# The code here sets up type checking and variable hiding for you.  You should not need to change anything below here.
sec_file_def = {"obj-type":ABFile,
                "name":"ABFile",
                "writeat":{"type":"func","args":(str,int),"exceptions":Exception,"return":(int,type(None)),"target":ABFile.writeat},
                "readat":{"type":"func","args":((int,type(None)),(int)),"exceptions":Exception,"return":str,"target":ABFile.readat},
                "close":{"type":"func","args":None,"exceptions":None,"return":(bool,type(None)),"target":ABFile.close}
           }

CHILD_CONTEXT_DEF["ABopenfile"] = {TYPE:OBJC,ARGS:(str,bool),EXCP:Exception,RETURN:sec_file_def,TARGET:ABopenfile}

# Execute the user code
secure_dispatch_module()